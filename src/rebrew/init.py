"""Initialize a new rebrew project directory.

Usage:
    rebrew-init [--target NAME] [--binary FILENAME] [--compiler PROFILE]
"""

from pathlib import Path

import typer

app = typer.Typer(help="Initialize a new rebrew project directory.")

DEFAULT_REBREW_TOML = '''# rebrew project configuration
# This file defines the target binaries, source layout, compiler, and
# architecture so that every tool reads from a single source of truth.
#
# Multiple targets are supported.  Tools default to the first target
# unless --target <name> is passed.

[targets."{target_name}"]
binary = "original/{binary_name}"
format = "pe"                        # pe | elf | macho
arch = "x86_32"                      # x86_32 | x86_64 | arm32 | arm64
reversed_dir = "src/{target_name}"   # directory containing reversed .c files
function_list = "src/{target_name}/functions.txt"
bin_dir = "bin/{target_name}"        # directory for extracted .bin files
origins = ["GAME"]                   # valid ORIGIN values for annotations

# Per-target cflags presets — keyed by ORIGIN, override global presets.
# [targets."{target_name}".cflags_presets]
# GAME = "/O2 /Gd"

# Per-target compiler override (optional — falls back to global [compiler]).
# [targets."{target_name}".compiler]
# command = "wine tools/MSVC600/VC98/Bin/CL.EXE"

# ---------------------------------------------------------------------------
# Global compiler settings — shared across all targets
# ---------------------------------------------------------------------------

[compiler]
profile = "{compiler_profile}"
command = "{compiler_command}"
includes = "{compiler_includes}"
libs = "{compiler_libs}"
cflags = "{cflags}"

[compiler.cflags_presets]
GAME = "{cflags}"

# Alternative compiler profiles — select with --profile <name> (future).
# [compiler.profiles.clang]
# command = "clang"
# includes = "/usr/include"
# libs = "/usr/lib"
# cflags = "-O2"
'''

COMPILER_DEFAULTS = {
    "msvc6": {
        "command": "wine tools/MSVC600/VC98/Bin/CL.EXE",
        "includes": "tools/MSVC600/VC98/Include",
        "libs": "tools/MSVC600/VC98/Lib",
        "cflags": "/O2 /Gd",
        "format": "pe",
        "arch": "x86_32",
        "lang": "C89",
    },
    "msvc7": {
        "command": "wine tools/MSVC7/Bin/CL.EXE",
        "includes": "tools/MSVC7/Include",
        "libs": "tools/MSVC7/Lib",
        "cflags": "/O2 /Gd",
        "format": "pe",
        "arch": "x86_32",
        "lang": "C99",
    },
    "clang": {
        "command": "clang",
        "includes": "/usr/include",
        "libs": "/usr/lib",
        "cflags": "-O2",
        "format": "elf",
        "arch": "x86_64",
        "lang": "C99",
    },
    "gcc": {
        "command": "gcc",
        "includes": "/usr/include",
        "libs": "/usr/lib",
        "cflags": "-O2",
        "format": "elf",
        "arch": "x86_64",
        "lang": "C99",
    },
}

DEFAULT_AGENTS_MD = '''# AGENTS.md — {project_name}

> Auto-generated by `rebrew-init`. Describes the decomp workflow for AI agents.

## Project

- **Target**: `{binary_name}` ({binary_format}, {arch})
- **Compiler**: {compiler_profile} (`{compiler_command}`)
- **Language**: {lang} — follow compiler constraints below
- **Config**: `rebrew.toml` (all tools read from here)

## Core Principles

- **Idempotent**: Every tool can be run repeatedly with the same result. Safe to retry or re-run.
- **Config-driven**: All tools read from `rebrew.toml` — zero manual paths needed.
- **Composable**: Small, single-purpose tools designed to be chained by scripts or AI agents.

## Workflow

```
1. rebrew-next --origin GAME          # pick next function
2. rebrew-skeleton 0x<VA>             # generate .c skeleton
3. # write implementation in src/{target_name}/<func>.c
4. rebrew-test src/{target_name}/<func>.c  # compile + compare
5. # iterate until STATUS: EXACT or RELOC
6. rebrew-catalog                     # update coverage
```

## CLI Tools

| Command | Use |
|---------|-----|
| `rebrew-next --stats` | Show coverage progress |
| `rebrew-next` | Find next function to reverse |
| `rebrew-skeleton 0x<VA>` | Generate C skeleton from address |
| `rebrew-test <file>` | Compile and byte-compare against target |
| `rebrew-match --diff-only <file>` | Show byte diff |
| `rebrew-match --flag-sweep-only <file>` | Find best compiler flags |
| `rebrew-match <file>` | Run GA matching engine |
| `rebrew-catalog` | Regenerate function catalog |
| `rebrew-verify` | Bulk verify all reversed files |
| `rebrew-cfg` | Read/edit rebrew.toml programmatically |

## Annotation Format

Every reversed `.c` file starts with:

```c
// FUNCTION: {target_name} 0x<virtual_address>
// STATUS: STUB
// ORIGIN: GAME
// SIZE: <bytes>
// CFLAGS: {cflags}
// SYMBOL: _function_name
```

**STATUS**: `EXACT` (byte-perfect) → `RELOC` (match after masking relocations)
→ `MATCHING` (close) → `STUB` (incomplete)

## Compiler Constraints ({compiler_profile})

{compiler_constraints}

## Flag Sweep

Flags are synced from decomp.me. Use `--tier` to control sweep effort:

| Tier | Combos | Use Case |
|------|--------|----------|
| `quick` | ~192 | Fast iteration |
| `normal` | ~21K | Default sweep |
| `thorough` | ~1M | Deep search |
| `full` | ~8.3M | Exhaustive (needs sampling) |

Re-sync: `python tools/sync_decomp_flags.py`
'''

MSVC_CONSTRAINTS = """- **C89 only**: no `for(int i=...)`, declare all variables at block top
- **Comments**: use `/* */` (not `//` in strict mode)
- **Symbol decoration**: `_func` for `__cdecl`, `_func@N` for `__stdcall`
- **No `/GS`** (buffer security), no `__declspec(noinline)`
- **Execution**: all CL.EXE/LINK.EXE calls go through Wine"""

MSVC7_CONSTRAINTS = """- **C99 subset**: `for(int i=...)` OK, `//` comments OK
- **Symbol decoration**: `_func` for `__cdecl`, `_func@N` for `__stdcall`
- **Supports `/fp:*`** (floating point model) and `/GS-` (buffer security)
- **Execution**: all CL.EXE/LINK.EXE calls go through Wine"""

GCC_CONSTRAINTS = """- **C99/C11**: standard modern C
- **Symbol decoration**: no leading underscore on Linux
- **ELF format**: use `objdump` / `readelf` for inspection"""


@app.callback(invoke_without_command=True)
def init(
    target_name: str = typer.Option("main", "--target", "-t", help="Name of the initial target."),
    binary_name: str = typer.Option("program.exe", "--binary", "-b", help="Name of the executable binary file."),
    compiler_profile: str = typer.Option("msvc6", "--compiler", "-c", help="Compiler profile to use."),
):
    """
    Initialize a new rebrew project in the current directory.

    Creates a rebrew.toml configuration, an AGENTS.md for AI agents,
    and the necessary directory structure for decompilation.
    """
    cwd = Path.cwd()
    toml_path = cwd / "rebrew.toml"

    if toml_path.exists():
        typer.secho(f"Error: A rebrew.toml already exists in {cwd}", fg=typer.colors.RED, err=True)
        raise typer.Exit(1)

    # Look up compiler defaults for the profile
    profile = COMPILER_DEFAULTS.get(compiler_profile, COMPILER_DEFAULTS["msvc6"])

    # 1. Write rebrew.toml
    toml_content = DEFAULT_REBREW_TOML.format(
        target_name=target_name,
        binary_name=binary_name,
        compiler_profile=compiler_profile,
        compiler_command=profile["command"],
        compiler_includes=profile["includes"],
        compiler_libs=profile["libs"],
        cflags=profile["cflags"],
    )
    toml_path.write_text(toml_content)
    typer.secho(f"Created {toml_path.name}", fg=typer.colors.GREEN)

    # 2. Write AGENTS.md (for LLM agents)
    if compiler_profile.startswith("msvc6"):
        constraints = MSVC_CONSTRAINTS
    elif compiler_profile.startswith("msvc"):
        constraints = MSVC7_CONSTRAINTS
    else:
        constraints = GCC_CONSTRAINTS

    agents_content = DEFAULT_AGENTS_MD.format(
        project_name=cwd.name,
        target_name=target_name,
        binary_name=binary_name,
        binary_format=profile.get("format", "pe"),
        arch=profile.get("arch", "x86_32"),
        compiler_profile=compiler_profile,
        compiler_command=profile["command"],
        compiler_constraints=constraints,
        cflags=profile["cflags"],
        lang=profile.get("lang", "C89"),
    )
    agents_path = cwd / "AGENTS.md"
    agents_path.write_text(agents_content)
    typer.secho(f"Created {agents_path.name} (AI agent instructions)", fg=typer.colors.GREEN)

    # 3. Create directories
    original_dir = cwd / "original"
    original_dir.mkdir(exist_ok=True)
    typer.secho(f"Created {original_dir.name}/ (Place your original binaries here)", fg=typer.colors.GREEN)

    src_dir = cwd / "src" / target_name
    src_dir.mkdir(parents=True, exist_ok=True)
    typer.secho(f"Created src/{target_name}/", fg=typer.colors.GREEN)

    bin_dir = cwd / "bin" / target_name
    bin_dir.mkdir(parents=True, exist_ok=True)
    typer.secho(f"Created bin/{target_name}/", fg=typer.colors.GREEN)

    # 4. Create empty function list
    func_list = src_dir / "functions.txt"
    func_list.touch(exist_ok=True)
    typer.secho(f"Created src/{target_name}/functions.txt", fg=typer.colors.GREEN)

    typer.secho("\nInitialization complete! Next steps:", fg=typer.colors.CYAN, bold=True)
    typer.echo(f"1. Copy your original binary to original/{binary_name}")
    typer.echo("2. Verify your compiler paths in rebrew.toml")
    typer.echo("3. Run 'rebrew-next --stats' to get started!")

def main_entry():
    app()

if __name__ == "__main__":
    main_entry()
