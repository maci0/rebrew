"""catalog/export.py - Catalog and CSV report generation.

Generates CATALOG.md markdown reports and reccmp-compatible CSV files
from parsed annotations and function registries.
"""

from typing import Any

from rebrew.config import ProjectConfig


def generate_catalog(
    entries: list[Any],
    r2_funcs: list[dict[str, Any]],
    text_size: int,
) -> str:
    """Generate CATALOG.md content."""
    # Deduplicate by VA (keep first occurrence per VA)
    by_va: dict[int, list[dict[str, Any]]] = {}
    for e in entries:
        if e.get("marker_type") in ("GLOBAL", "DATA"):
            continue
        by_va.setdefault(e["va"], []).append(e)

    unique_vas = set(by_va.keys())
    exact_count = sum(1 for vas in by_va.values() if any(e["status"] == "EXACT" for e in vas))
    reloc_count = sum(
        1
        for vas in by_va.values()
        if any(e["status"] in ("RELOC", "MATCHING_RELOC") for e in vas)
        and not any(e["status"] == "EXACT" for e in vas)
    )
    stub_count = sum(
        1
        for vas in by_va.values()
        if any(e["status"] == "STUB" for e in vas)
        and not any(e["status"] in ("EXACT", "RELOC", "MATCHING_RELOC", "MATCHING") for e in vas)
    )

    # Coverage bytes
    r2_by_va = {f["va"]: f for f in r2_funcs}
    covered_bytes = 0
    for va in unique_vas:
        if va in r2_by_va:
            covered_bytes += r2_by_va[va]["size"]
        elif by_va[va]:
            covered_bytes += by_va[va][0]["size"]

    total_funcs = len(r2_funcs)
    matched_count = len(unique_vas)
    coverage_pct = (covered_bytes / text_size * 100.0) if text_size else 0.0

    lines = []
    lines.append("# Reversed Functions Catalog\n")
    lines.append(
        f"Total: {matched_count}/{total_funcs} functions matched "
        f"({exact_count} exact, {reloc_count} reloc-normalized, {stub_count} stubs)  "
    )
    lines.append(
        f"Coverage: {coverage_pct:.1f}% of .text section ({covered_bytes}/{text_size} bytes)\n"
    )

    # Group by origin (discovered dynamically from data, excluding GLOBAL/DATA)
    by_origin: dict[str, list[dict[str, Any]]] = {}
    for e in entries:
        if e.get("marker_type") in ("GLOBAL", "DATA"):
            continue
        origin = e["origin"]
        by_origin.setdefault(origin, []).append(e)

    for origin in sorted(by_origin):
        group = sorted(by_origin.get(origin, []), key=lambda x: x["va"])
        lines.append(f"\n## {origin} ({len(group)} functions)\n")
        lines.append("| VA | Size | Name | Symbol | Flags | Match | File |")
        lines.append("|-----|------|------|--------|-------|-------|------|")
        for e in group:
            va_str = f"0x{e['va']:08X}"
            match_str = f"{e['marker_type']}/{e['status']}"
            lines.append(
                f"| {va_str} | {e['size']}B | {e['name']} | "
                f"{e['symbol']} | {e['cflags']} | {match_str} | {e['filepath']} |"
            )

    # Unmatched functions
    unmatched = [f for f in r2_funcs if f["va"] not in unique_vas]
    unmatched.sort(key=lambda x: x["va"])
    lines.append(f"\n## Unmatched Functions ({len(unmatched)} remaining)\n")
    lines.append("| VA | Size | r2 Name |")
    lines.append("|-----|------|---------|")
    for f in unmatched:
        lines.append(f"| 0x{f['va']:08X} | {f['size']}B | {f['r2_name']} |")

    lines.append("")
    return "\n".join(lines)


# ---------------------------------------------------------------------------
# reccmp-compatible CSV generation
# ---------------------------------------------------------------------------


def _reccmp_type(entry: Any) -> str:
    """Map our marker_type + origin to reccmp entity type."""
    if entry["marker_type"] == "STUB":
        return "stub"
    if entry["origin"] in ("ZLIB", "MSVCRT"):
        return "library"
    return "function"


def generate_reccmp_csv(
    entries: list[Any],
    r2_funcs: list[dict[str, Any]],
    registry: dict[int, dict[str, Any]] | None = None,
    target_name: str = "TARGET",
    cfg: ProjectConfig | None = None,
) -> str:
    """Generate reccmp-compatible pipe-delimited CSV.

    Format per https://github.com/isledecomp/reccmp/blob/master/docs/csv.md:
      address|name|symbol|type|size

    Includes ALL known functions (matched + unmatched), so the CSV serves as
    a complete function catalog for the binary.  Comments and blank lines are
    allowed by the reccmp spec.
    """
    by_va: dict[int, dict[str, Any]] = {}
    for e in entries:
        if e["va"] not in by_va:
            by_va[e["va"]] = e

    r2_by_va = {f["va"]: f for f in r2_funcs}

    lines: list[str] = []
    lines.append(f"# reccmp-compatible function catalog for {target_name}")
    lines.append("# Generated by validate.py â€” do not edit manually")
    lines.append("#")
    lines.append("# Columns: address (hex) | name | symbol | type | size (decimal)")
    lines.append("")
    lines.append("address|name|symbol|type|size")

    # Collect all known VAs from registry + annotations
    all_vas: set[int] = set()
    if registry:
        all_vas.update(registry.keys())
    all_vas.update(by_va.keys())
    all_vas.update(r2_by_va.keys())

    for va in sorted(all_vas):
        va_hex = f"0x{va:08x}"

        if va in by_va:
            e = by_va[va]
            name = e["name"]
            symbol = e["symbol"]
            etype = _reccmp_type(e)
            # Use canonical size from registry if available
            size = e["size"]
            if registry and va in registry:
                cs = registry[va].get("canonical_size", 0)
                if cs > 0:
                    size = cs
            lines.append(f"{va_hex}|{name}|{symbol}|{etype}|{size}")
        else:
            # Unmatched function â€” pull name from Ghidra/r2
            reg = registry.get(va, {}) if registry else {}
            name = ""
            if reg.get("ghidra_name", ""):
                gn = reg["ghidra_name"]
                if not gn.startswith("FUN_"):
                    name = gn
            if not name and va in r2_by_va:
                rn = r2_by_va[va]["r2_name"]
                if not rn.startswith("fcn.") and not rn.startswith("sym."):
                    name = rn

            # Determine type
            is_thunk = reg.get("is_thunk", False)
            if not is_thunk and cfg:
                is_thunk = va in cfg.iat_thunks
            etype = "function"
            if is_thunk:
                etype = "stub"

            # Size
            size = reg.get("canonical_size", 0) if reg else 0
            if not size and va in r2_by_va:
                size = r2_by_va[va]["size"]

            symbol = f"_{name}" if name else ""
            size_str = str(size) if size > 0 else ""
            lines.append(f"{va_hex}|{name}|{symbol}|{etype}|{size_str}")

    lines.append("")
    return "\n".join(lines)
