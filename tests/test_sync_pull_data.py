import sys
from types import SimpleNamespace
from typing import Any

from rebrew.sync import _pull_data


class _FakeClient:
    def __init__(self, timeout: float) -> None:
        self.timeout = timeout

    def __enter__(self) -> "_FakeClient":
        return self

    def __exit__(self, exc_type: Any, exc: Any, tb: Any) -> None:
        return None


def _mock_httpx(monkeypatch: Any) -> None:
    fake_httpx = SimpleNamespace(
        Client=lambda timeout: _FakeClient(timeout),
        RequestError=RuntimeError,
    )
    monkeypatch.setitem(sys.modules, "httpx", fake_httpx)


def _run_pull_data(
    monkeypatch: Any,
    tmp_path: Any,
    symbols: list[dict[str, Any]],
    data_by_addr: dict[str, dict[str, Any]],
    *,
    dry_run: bool = False,
    sections: list[dict[str, Any]] | None = None,
) -> None:
    _mock_httpx(monkeypatch)

    def _fake_init(client: Any, endpoint: str) -> str:
        _ = client, endpoint
        return "session-1"

    def _fake_fetch_raw(
        client: Any,
        endpoint: str,
        tool_name: str,
        arguments: dict[str, Any],
        request_id: int,
        session_id: str = "",
    ) -> Any:
        _ = client, endpoint, request_id, session_id
        if tool_name == "get-symbols-count":
            return {"count": len(symbols)}
        if tool_name == "get-symbols":
            start = int(arguments["startIndex"])
            max_count = int(arguments["maxCount"])
            return symbols[start : start + max_count]
        if tool_name == "get-data":
            return data_by_addr.get(str(arguments["addressOrSymbol"]))
        raise AssertionError(f"unexpected tool call: {tool_name}")

    monkeypatch.setattr("rebrew.sync._init_mcp_session", _fake_init)
    monkeypatch.setattr("rebrew.sync._fetch_mcp_tool_raw", _fake_fetch_raw)

    if sections is not None:
        sec_objs = {
            sec["name"]: SimpleNamespace(
                name=sec["name"],
                va=sec["va"],
                size=sec["size"],
                raw_size=sec.get("raw_size", sec["size"]),
            )
            for sec in sections
        }

        def _fake_load_binary(path: Any, fmt: str = "auto") -> Any:
            _ = path, fmt
            return SimpleNamespace(sections=sec_objs)

        monkeypatch.setitem(
            sys.modules,
            "rebrew.binary_loader",
            SimpleNamespace(load_binary=_fake_load_binary),
        )

    cfg = SimpleNamespace(
        reversed_dir=tmp_path,
        target_binary=tmp_path / "target.exe",
        format="pe",
    )
    _pull_data(cfg, "http://localhost:8080/mcp/message", "/target.exe", dry_run)


class TestPullDataGlobalsHeader:
    def test_generates_header_file(self, tmp_path: Any, monkeypatch: Any) -> None:
        symbols = [
            {"name": "g_playerCount", "address": "0x00403010", "isFunction": False},
            {"name": "g_windowTitle", "address": "0x00403014", "isFunction": False},
        ]
        data_by_addr = {
            "0x00403010": {
                "address": "0x00403010",
                "dataType": "int",
                "length": 4,
                "symbolName": "g_playerCount",
            },
            "0x00403014": {
                "address": "0x00403014",
                "dataType": "pointer",
                "length": 4,
                "symbolName": "g_windowTitle",
            },
        }
        _run_pull_data(monkeypatch, tmp_path, symbols, data_by_addr)

        header = (tmp_path / "rebrew_globals.h").read_text(encoding="utf-8")
        assert "Auto-generated by rebrew sync --pull-data" in header
        assert "extern int g_playerCount;" in header
        assert "extern void* g_windowTitle;" in header

    def test_type_mapping_int(self, tmp_path: Any, monkeypatch: Any) -> None:
        symbols = [{"name": "g_value", "address": "0x00403010", "isFunction": False}]
        data_by_addr = {
            "0x00403010": {
                "address": "0x00403010",
                "dataType": "int",
                "length": 4,
                "symbolName": "g_value",
            }
        }
        _run_pull_data(monkeypatch, tmp_path, symbols, data_by_addr)
        header = (tmp_path / "rebrew_globals.h").read_text(encoding="utf-8")
        assert "extern int g_value;" in header

    def test_type_mapping_pointer(self, tmp_path: Any, monkeypatch: Any) -> None:
        symbols = [{"name": "g_ptr", "address": "0x00403010", "isFunction": False}]
        data_by_addr = {
            "0x00403010": {
                "address": "0x00403010",
                "dataType": "pointer32",
                "length": 4,
                "symbolName": "g_ptr",
            }
        }
        _run_pull_data(monkeypatch, tmp_path, symbols, data_by_addr)
        header = (tmp_path / "rebrew_globals.h").read_text(encoding="utf-8")
        assert "extern void* g_ptr;" in header

    def test_type_mapping_undefined(self, tmp_path: Any, monkeypatch: Any) -> None:
        symbols = [{"name": "g_blob", "address": "0x00403010", "isFunction": False}]
        data_by_addr = {
            "0x00403010": {
                "address": "0x00403010",
                "dataType": "undefined4",
                "length": 4,
                "symbolName": "g_blob",
            }
        }
        _run_pull_data(monkeypatch, tmp_path, symbols, data_by_addr)
        header = (tmp_path / "rebrew_globals.h").read_text(encoding="utf-8")
        assert "extern unsigned char g_blob[4];" in header

    def test_type_mapping_array(self, tmp_path: Any, monkeypatch: Any) -> None:
        symbols = [{"name": "g_name", "address": "0x00405000", "isFunction": False}]
        data_by_addr = {
            "0x00405000": {
                "address": "0x00405000",
                "dataType": "char[32]",
                "length": 32,
                "symbolName": "g_name",
            }
        }
        _run_pull_data(monkeypatch, tmp_path, symbols, data_by_addr)
        header = (tmp_path / "rebrew_globals.h").read_text(encoding="utf-8")
        assert "extern char g_name[32];" in header

    def test_type_mapping_float(self, tmp_path: Any, monkeypatch: Any) -> None:
        symbols = [
            {"name": "g_f", "address": "0x00403010", "isFunction": False},
            {"name": "g_d", "address": "0x00403018", "isFunction": False},
        ]
        data_by_addr = {
            "0x00403010": {
                "address": "0x00403010",
                "dataType": "float",
                "length": 4,
                "symbolName": "g_f",
            },
            "0x00403018": {
                "address": "0x00403018",
                "dataType": "double",
                "length": 8,
                "symbolName": "g_d",
            },
        }
        _run_pull_data(monkeypatch, tmp_path, symbols, data_by_addr)
        header = (tmp_path / "rebrew_globals.h").read_text(encoding="utf-8")
        assert "extern float g_f;" in header
        assert "extern double g_d;" in header

    def test_filters_function_symbols(self, tmp_path: Any, monkeypatch: Any) -> None:
        symbols = [
            {"name": "real_fn", "address": "0x00401000", "isFunction": True},
            {"name": "g_ok", "address": "0x00403010", "isFunction": False},
        ]
        requests: list[str] = []

        def _fake_init(client: Any, endpoint: str) -> str:
            _ = client, endpoint
            return "session-1"

        def _fake_fetch_raw(
            client: Any,
            endpoint: str,
            tool_name: str,
            arguments: dict[str, Any],
            request_id: int,
            session_id: str = "",
        ) -> Any:
            _ = client, endpoint, request_id, session_id
            if tool_name == "get-symbols-count":
                return {"count": len(symbols)}
            if tool_name == "get-symbols":
                start = int(arguments["startIndex"])
                max_count = int(arguments["maxCount"])
                return symbols[start : start + max_count]
            if tool_name == "get-data":
                addr = str(arguments["addressOrSymbol"])
                requests.append(addr)
                return {
                    "address": addr,
                    "dataType": "int",
                    "length": 4,
                    "symbolName": "g_ok",
                }
            raise AssertionError(f"unexpected tool call: {tool_name}")

        _mock_httpx(monkeypatch)
        monkeypatch.setattr("rebrew.sync._init_mcp_session", _fake_init)
        monkeypatch.setattr("rebrew.sync._fetch_mcp_tool_raw", _fake_fetch_raw)
        cfg = SimpleNamespace(
            reversed_dir=tmp_path,
            target_binary=tmp_path / "target.exe",
            format="pe",
        )

        _pull_data(cfg, "http://localhost:8080/mcp/message", "/target.exe", False)

        assert requests == ["0x00403010"]

    def test_dry_run_no_write(self, tmp_path: Any, monkeypatch: Any, capsys: Any) -> None:
        symbols = [{"name": "g_value", "address": "0x00403010", "isFunction": False}]
        data_by_addr = {
            "0x00403010": {
                "address": "0x00403010",
                "dataType": "int",
                "length": 4,
                "symbolName": "g_value",
            }
        }
        _run_pull_data(monkeypatch, tmp_path, symbols, data_by_addr, dry_run=True)

        assert not (tmp_path / "rebrew_globals.h").exists()
        out = capsys.readouterr().out
        assert "Dry run: would write" in out

    def test_empty_symbols_no_file(self, tmp_path: Any, monkeypatch: Any) -> None:
        _run_pull_data(monkeypatch, tmp_path, [], {}, dry_run=False)
        assert not (tmp_path / "rebrew_globals.h").exists()

    def test_header_has_include_guard(self, tmp_path: Any, monkeypatch: Any) -> None:
        symbols = [{"name": "g_value", "address": "0x00403010", "isFunction": False}]
        data_by_addr = {
            "0x00403010": {
                "address": "0x00403010",
                "dataType": "int",
                "length": 4,
                "symbolName": "g_value",
            }
        }
        _run_pull_data(monkeypatch, tmp_path, symbols, data_by_addr)
        header = (tmp_path / "rebrew_globals.h").read_text(encoding="utf-8")
        assert "#ifndef REBREW_GLOBALS_H" in header
        assert "#define REBREW_GLOBALS_H" in header
        assert "#endif /* REBREW_GLOBALS_H */" in header

    def test_section_grouping(self, tmp_path: Any, monkeypatch: Any) -> None:
        symbols = [
            {"name": "g_data", "address": "0x00403010", "isFunction": False},
            {"name": "g_const", "address": "0x00405010", "isFunction": False},
            {"name": "g_bss", "address": "0x00406010", "isFunction": False},
        ]
        data_by_addr = {
            "0x00403010": {
                "address": "0x00403010",
                "dataType": "int",
                "length": 4,
                "symbolName": "g_data",
            },
            "0x00405010": {
                "address": "0x00405010",
                "dataType": "char[16]",
                "length": 16,
                "symbolName": "g_const",
            },
            "0x00406010": {
                "address": "0x00406010",
                "dataType": "int",
                "length": 4,
                "symbolName": "g_bss",
            },
        }
        sections = [
            {"name": ".data", "va": 0x00403000, "size": 0x1000},
            {"name": ".rdata", "va": 0x00405000, "size": 0x1000},
            {"name": ".bss", "va": 0x00406000, "size": 0x1000},
        ]

        _run_pull_data(monkeypatch, tmp_path, symbols, data_by_addr, sections=sections)
        header = (tmp_path / "rebrew_globals.h").read_text(encoding="utf-8")
        assert "/* .data section globals */" in header
        assert "/* .rdata section globals */" in header
        assert "/* .bss section globals */" in header
