# FLIRT Signatures Guide

How to obtain, create, and use [IDA FLIRT](https://hex-rays.com/products/ida/tech/flirt/)
signatures with rebrew — **no IDA Pro required**.

## Background

FLIRT (Fast Library Identification and Recognition Technology) signatures identify
known library functions inside a binary by matching byte patterns. When you match
a function to a FLIRT signature you get a **free win** — the function can be
attributed to a specific library (CRT, zlib, Lua, etc.) without manual RE.

Rebrew uses the [`python-flirt`](https://pypi.org/project/python-flirt/) library
to load and match `.sig` / `.pat` files entirely offline.

## Supported Formats

| Format | Extension | Origin | Notes |
|--------|-----------|--------|-------|
| **PAT** (pattern) | `.pat` | Text-based, human-readable | One pattern per line. Can be generated by rebrew's `gen_flirt_pat.py` or IDA's `pelf`/`pcf` |
| **SIG** (signature) | `.sig` | Binary, compiled from `.pat` | Produced by IDA's `sigmake` tool. Faster to load for large databases |

Both formats are loaded transparently by `rebrew-flirt`.

## Obtaining Pre-made Signatures

### Community Repositories

Several open-source repos collect pre-built FLIRT signatures for common compilers
and libraries:

| Repository | URL | Coverage |
|------------|-----|----------|
| **Maktm/FLIRTDB** | [github.com/Maktm/FLIRTDB](https://github.com/Maktm/FLIRTDB) | MSVC, Borland, MinGW, Lua, etc. Has VC6 signatures |
| **push0ebp/sig-database** | [github.com/push0ebp/sig-database](https://github.com/push0ebp/sig-database) | Broad MSVC coverage (VC12+) |
| **Mandiant/siglib** | [github.com/mandiant/siglib](https://github.com/mandiant/siglib) | FLARE team sigs, strong on malware-adjacent CRTs |

**Quick start — clone and copy:**

```bash
# Example: grab Maktm's FLIRTDB
git clone https://github.com/Maktm/FLIRTDB.git /tmp/FLIRTDB

# Copy the VC6 CRT signatures into your project's flirt_sigs/ directory
cp /tmp/FLIRTDB/vc6/*.sig flirt_sigs/

# Or copy everything
cp /tmp/FLIRTDB/**/*.sig flirt_sigs/
```

### IDA Pro (if available)

If you have access to IDA Pro, its installation ships with a large set of
pre-compiled `.sig` files:

```
<IDA_DIR>/sig/pc/          # x86 signatures
<IDA_DIR>/sig/ppc/         # PowerPC signatures
```

Copy the relevant `.sig` files into your project's `flirt_sigs/` directory.

### From Library Vendors

Some library authors distribute FLIRT signatures or object archives you can
convert. For example, the Lua project provides pre-built static libraries
for MSVC that can be converted to `.pat` (see below).

## Creating Your Own Signatures

### Method 1: From a COFF `.lib` Archive (recommended)

This is the primary method for MSVC targets. If you have the original static
library (`.lib`) that was linked into the binary, you can generate a `.pat`
file directly. Rebrew includes `gen_flirt_pat.py` for this purpose.

**Usage:**

```bash
# Generate a .pat from the MSVC6 CRT library
uv run python -m rebrew.gen_flirt_pat tools/MSVC600/VC98/Lib/LIBCMT.LIB \
    -o flirt_sigs/libcmt_vc6.pat
```

**How it works:**

1. Parses the COFF archive to extract every object file member
2. Finds every public function symbol in each object
3. Reads the function's code bytes and COFF relocations
4. Emits a `.pat` line with relocation bytes masked as `..`

The resulting `.pat` file looks like this:

```
558BEC83EC0C56578B7D0C85FF0F84........8B750883C604 40 A1B2 0064 :0000 _inflate_init
```

Each line contains:
- **Leading bytes** (up to 32) with relocations masked as `..`
- **CRC length + CRC16** of bytes after the leading portion
- **Total function size**
- **Symbol name**

**Common libraries to generate patterns for:**

| Library | Source Path (MSVC6) | Output |
|---------|-------------------|--------|
| CRT (multithreaded) | `tools/MSVC600/VC98/Lib/LIBCMT.LIB` | `flirt_sigs/libcmt_vc6.pat` |
| CRT (single-threaded) | `tools/MSVC600/VC98/Lib/LIBC.LIB` | `flirt_sigs/libc_vc6.pat` |
| C++ Standard Library | `tools/MSVC600/VC98/Lib/LIBCP.LIB` | `flirt_sigs/libcp_vc6.pat` |
| Old I/O streams | `tools/MSVC600/VC98/Lib/OLDNAMES.LIB` | `flirt_sigs/oldnames_vc6.pat` |

**For third-party libraries**, build them from source with the same compiler
version and flags, then generate a `.pat` from the resulting `.lib`:

```bash
# Example: build zlib 1.1.3 with MSVC6 and generate signatures
wine tools/MSVC600/VC98/Bin/CL.EXE /nologo /c /O2 /MT references/zlib-1.1.3/*.c
wine tools/MSVC600/VC98/Bin/LIB.EXE /nologo /out:zlib_vc6.lib *.obj
uv run python -m rebrew.gen_flirt_pat zlib_vc6.lib -o flirt_sigs/zlib113_vc6.pat
```

### Method 2: Using IDA's `sigmake` / `pelf` / `pcf`

If you have IDA Pro's **FLAIR** (Fast Library Acquisition for Identification
and Recognition) utilities, you can create signatures using IDA's official
toolchain. The FLAIR tools are distributed with IDA Pro and SDK.

**Workflow:**

```
.lib/.a → pelf/pcf/plb → .pat → sigmake → .sig
```

1. **Extract patterns** from a library archive:
   ```bash
   # For COFF/PE .lib files
   pcf my_library.lib my_library.pat

   # For ELF .a files
   pelf my_library.a my_library.pat

   # For OMF (Borland) .lib files
   plb my_library.lib my_library.pat
   ```

2. **Compile patterns** into a `.sig` file:
   ```bash
   sigmake my_library.pat my_library.sig
   ```

3. If `sigmake` reports **collisions** (multiple functions with identical
   leading bytes), it creates an `.exc` (exclusion) file. Edit this file
   to resolve ambiguities, then re-run `sigmake`:
   ```bash
   # Edit my_library.exc — uncomment the function you want to keep
   # for each collision group, then:
   sigmake my_library.pat my_library.sig
   ```

> [!NOTE]
> The FLAIR utilities are **not required** for rebrew. Rebrew's built-in
> `gen_flirt_pat.py` produces `.pat` files that `python-flirt` can load
> directly. Use the IDA toolchain only if you need `.sig` files specifically
> or need to handle collision resolution for very large signature databases.

### Method 3: Hand-crafted `.pat` Patterns

For individual functions you want to tag (e.g., a custom allocator you've
identified), you can write a `.pat` entry by hand:

```
558BEC6AFF68........64A10000000050 1A 5678 0080 :0000 _my_custom_alloc
```

**Format of a `.pat` line:**

```
<leading hex bytes with .. for relocs> <crc_len hex> <crc16 hex> <total_size hex> :0000 <symbol_name>
```

| Field | Description |
|-------|-------------|
| Leading bytes | First 32 (max) bytes of the function in hex. Use `..` for any relocatable byte |
| CRC length | Number of bytes after the leading portion used for CRC (hex, max `FF`) |
| CRC16 | CRC-CCITT of the non-reloc bytes after the leading portion |
| Total size | Total function size in bytes (hex) |
| `:0000` | Offset of the symbol within the pattern (usually `0000`) |
| Symbol name | The function name to assign on match |

The file must end with a line containing only `---`.

> [!TIP]
> For hand-crafted patterns, you can set CRC length and CRC16 to `00 0000`
> if the leading bytes are sufficiently unique (≥16 non-wildcard bytes).
> The matching engine will still work, just with slightly less precision
> for very short patterns.

## Using Signatures with Rebrew

### Scanning a Target Binary

```bash
# Scan using the default flirt_sigs/ directory
uv run python -m rebrew.flirt

# Scan with a custom signature directory
uv run python -m rebrew.flirt /path/to/my/signatures/

# Scan a different target binary
uv run python -m rebrew.flirt flirt_sigs/ --exe original/MyGame/mygame.exe

# Only report functions larger than 32 bytes
uv run python -m rebrew.flirt flirt_sigs/ --min-size 32
```

### Interpreting Results

```
[+] 0x10001a20 (  64B): __sbh_heap_init
[+] 0x10001b80 ( 128B): _malloc
[+] 0x10005620 (  96B): _inflate
```

Each line shows:
- The **virtual address** where the signature matched
- The estimated **function size**
- The **symbol name** from the signature database

Functions identified this way can be marked as `LIBRARY` origin in your
annotation headers without manually reversing them.

### Directory Layout

Place all signatures in a `flirt_sigs/` directory at your project root:

```
your-project/
├── flirt_sigs/
│   ├── libcmt_vc6.pat      # generated from MSVC6 CRT
│   ├── zlib113_vc6.pat      # generated from zlib 1.1.3
│   ├── lua503_vc6.sig       # community sig for Lua 5.0.3
│   └── custom_engine.pat    # hand-crafted patterns
├── original/
├── src/
└── rebrew.toml
```

## Troubleshooting

| Problem | Cause | Fix |
|---------|-------|-----|
| No matches found | Wrong compiler version or optimization flags | Generate sigs from the exact library version linked into the binary |
| Too many ambiguous matches | Overly broad signature database | Use `--min-size 32` to skip tiny functions, or use more targeted `.pat` files |
| `flirt` module not found | Missing dependency | Run `uv sync` to install `python-flirt` |
| `.sig` file won't load | Incompatible format or corrupt file | Try the `.pat` equivalent; `python-flirt` supports both but older `.sig` versions may fail |
| Functions not detected at expected VAs | Binary may not be 16-byte aligned | The scanner uses 16-byte stride by default; some functions may start at odd alignments |
